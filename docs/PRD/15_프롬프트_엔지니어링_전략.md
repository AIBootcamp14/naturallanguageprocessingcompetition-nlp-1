# 🎯 프롬프트 엔지니어링 전략

## 📚 프롬프트 엔지니어링 개요

### 목적
- Solar API 및 LLM의 성능 극대화
- 토큰 사용량 최소화하면서 품질 유지
- 대화 특성별 최적 프롬프트 적용
- 일관된 출력 형식 보장

## 🔬 프롬프트 설계 원칙

### 1. 명확성 (Clarity)
```python
# ❌ 나쁜 예
prompt = "대화를 요약해주세요"

# ✅ 좋은 예
prompt = """다음 대화의 핵심 내용을 3-5문장으로 요약해주세요.
주요 주제, 결정사항, 중요한 정보를 포함시켜주세요."""
```

### 2. 구조화 (Structure)
```python
structured_prompt = {
    "role": "당신은 대화 요약 전문가입니다",
    "task": "일상 대화를 간결하고 정확하게 요약",
    "format": "3-5문장, 핵심 정보 중심",
    "constraints": "개인정보 제외, 중립적 톤"
}
```

### 3. 맥락 제공 (Context)
```python
def add_context(dialogue, metadata):
    context = f"""
    대화 참여자: {metadata['num_speakers']}명
    대화 길이: {metadata['num_turns']}턴
    주제: {metadata['topic']}
    """
    return context
```

## 📝 프롬프트 템플릿 라이브러리

### 1. Zero-shot 템플릿
```python
ZERO_SHOT_TEMPLATES = {
    "basic": """
    다음 대화를 요약해주세요:
    {dialogue}

    요약:
    """,

    "detailed": """
    아래 대화를 읽고 핵심 내용을 요약해주세요.

    요구사항:
    - 3-5문장으로 작성
    - 주요 주제와 결론 포함
    - 중요한 정보 누락 없이

    대화:
    {dialogue}

    요약:
    """,

    "structured": """
    [태스크] 대화 요약
    [형식] 한 문단, 3-5문장
    [스타일] 객관적, 간결함

    대화 내용:
    {dialogue}

    요약 결과:
    """
}
```

### 2. Few-shot 템플릿
```python
FEW_SHOT_TEMPLATES = {
    "2_shot": """
    대화 요약 예시를 참고하여 마지막 대화를 요약해주세요.

    예시 1:
    대화: {example1_dialogue}
    요약: {example1_summary}

    예시 2:
    대화: {example2_dialogue}
    요약: {example2_summary}

    이제 다음 대화를 요약해주세요:
    대화: {target_dialogue}
    요약:
    """,

    "3_shot_with_explanation": """
    다음은 대화 요약 예시입니다. 패턴을 학습하여 적용해주세요.

    [예시 1]
    대화: {ex1_dialogue}
    요약: {ex1_summary}
    설명: {ex1_explanation}

    [예시 2]
    대화: {ex2_dialogue}
    요약: {ex2_summary}
    설명: {ex2_explanation}

    [예시 3]
    대화: {ex3_dialogue}
    요약: {ex3_summary}
    설명: {ex3_explanation}

    [실제 과제]
    대화: {dialogue}
    요약:
    """
}
```

### 3. Chain-of-Thought (CoT) 템플릿
```python
COT_TEMPLATES = {
    "step_by_step": """
    다음 대화를 단계별로 분석하여 요약해주세요.

    단계 1: 대화의 주요 주제 파악
    단계 2: 핵심 정보와 결정사항 추출
    단계 3: 부수적 정보 제거
    단계 4: 간결한 문장으로 정리

    대화:
    {dialogue}

    단계별 분석:
    1. 주요 주제:
    2. 핵심 정보:
    3. 제거할 내용:
    4. 최종 요약:
    """,

    "analytical": """
    대화를 분석적으로 요약해주세요.

    대화: {dialogue}

    먼저 생각해봅시다:
    - 이 대화의 목적은 무엇인가?
    - 어떤 결론에 도달했는가?
    - 가장 중요한 정보는 무엇인가?

    이를 바탕으로 한 요약:
    """
}
```

## 🎭 대화 특성별 동적 프롬프트

### 1. 대화 길이별 전략
```python
def get_prompt_by_length(dialogue, word_count):
    if word_count < 200:
        return TEMPLATES["short_dialogue"]
    elif word_count < 500:
        return TEMPLATES["medium_dialogue"]
    else:
        return TEMPLATES["long_dialogue"]

TEMPLATES = {
    "short_dialogue": """
    짧은 대화입니다. 핵심만 간단히 요약해주세요:
    {dialogue}
    """,

    "medium_dialogue": """
    다음 대화의 주요 내용을 3-4문장으로 요약해주세요:
    {dialogue}
    """,

    "long_dialogue": """
    긴 대화입니다. 주요 주제별로 구조화하여 5-6문장으로 요약해주세요:
    {dialogue}
    """
}
```

### 2. 참여자 수별 전략
```python
def get_prompt_by_speakers(dialogue, num_speakers):
    if num_speakers == 2:
        template = "두 사람의 대화입니다. 각자의 입장과 합의점을 중심으로 요약:"
    elif num_speakers <= 4:
        template = "소그룹 대화입니다. 주요 의견들과 결론을 정리:"
    else:
        template = "다수가 참여한 대화입니다. 핵심 주제와 주요 결정사항 중심으로 요약:"

    return f"{template}\n{dialogue}"
```

### 3. 주제별 특화 프롬프트
```python
TOPIC_SPECIFIC_PROMPTS = {
    "일상": "일상적인 대화의 따뜻함을 유지하며 핵심 내용 요약",
    "업무": "업무 관련 결정사항과 액션 아이템 중심으로 요약",
    "교육": "학습 내용과 핵심 개념을 명확하게 정리",
    "의료": "증상, 진단, 처방 등 의료 정보를 정확하게 요약",
    "기술": "기술적 용어와 해결 방법을 명확하게 포함하여 요약"
}
```

## 🧪 프롬프트 A/B 테스팅

### 1. 테스팅 프레임워크
```python
class PromptABTester:
    def __init__(self):
        self.results = defaultdict(list)

    def test_prompts(self, dialogue, prompts_dict):
        """여러 프롬프트를 테스트하고 성능 비교"""
        results = {}

        for name, prompt in prompts_dict.items():
            summary = self.generate_summary(prompt, dialogue)
            score = self.evaluate_summary(summary, reference)

            results[name] = {
                'summary': summary,
                'rouge_score': score,
                'token_count': self.count_tokens(prompt),
                'response_time': response_time
            }

        return self.select_best(results)

    def select_best(self, results):
        """성능과 효율성을 고려한 최적 프롬프트 선택"""
        scores = []
        for name, metrics in results.items():
            # 성능 70%, 토큰 효율성 30% 가중치
            combined_score = (
                metrics['rouge_score'] * 0.7 +
                (1 - metrics['token_count']/1000) * 0.3
            )
            scores.append((name, combined_score))

        return max(scores, key=lambda x: x[1])
```

### 2. 실험 관리
```python
EXPERIMENTS = {
    "exp_001": {
        "hypothesis": "CoT 프롬프트가 Zero-shot보다 성능 향상",
        "variants": ["zero_shot", "cot_simple", "cot_detailed"],
        "metrics": ["rouge", "coherence", "token_efficiency"]
    },
    "exp_002": {
        "hypothesis": "Few-shot이 긴 대화에서 더 효과적",
        "variants": ["zero_shot", "2_shot", "3_shot", "5_shot"],
        "filter": "dialogue_length > 500"
    }
}
```

## 💰 토큰 효율 최적화

### 1. 프롬프트 압축 전략
```python
def compress_prompt(prompt, dialogue):
    """불필요한 부분 제거로 토큰 절약"""

    # 1. 반복 제거
    prompt = remove_repetitions(prompt)

    # 2. 대화 전처리
    dialogue = preprocess_dialogue(dialogue)

    # 3. 지시사항 간소화
    prompt = simplify_instructions(prompt)

    return prompt

def remove_repetitions(text):
    """중복 문구 제거"""
    # "#Person1#:" → "A:"
    text = re.sub(r'#Person(\d+)#:', r'P\1:', text)

    # 연속 공백 제거
    text = re.sub(r'\s+', ' ', text)

    return text
```

### 2. 적응형 프롬프트 길이
```python
def adaptive_prompt_length(dialogue, token_budget=500):
    """토큰 예산에 맞춰 프롬프트 조정"""

    dialogue_tokens = count_tokens(dialogue)

    if dialogue_tokens > token_budget * 0.8:
        # 대화가 길면 짧은 프롬프트
        return MINIMAL_PROMPT
    elif dialogue_tokens > token_budget * 0.5:
        # 중간 길이
        return STANDARD_PROMPT
    else:
        # 여유있으면 상세 프롬프트
        return DETAILED_PROMPT
```

## 📊 프롬프트 성능 모니터링

### 1. 메트릭 추적
```python
class PromptMetrics:
    def __init__(self):
        self.metrics = {
            'rouge_scores': [],
            'token_usage': [],
            'response_times': [],
            'failure_rates': {}
        }

    def log_performance(self, prompt_type, metrics):
        """프롬프트별 성능 기록"""
        self.metrics[prompt_type].append({
            'timestamp': datetime.now(),
            'rouge': metrics['rouge'],
            'tokens': metrics['tokens'],
            'latency': metrics['latency']
        })

    def get_best_prompt(self, context):
        """컨텍스트별 최적 프롬프트 추천"""
        relevant_data = self.filter_by_context(context)
        return self.rank_prompts(relevant_data)[0]
```

### 2. 프롬프트 버전 관리
```python
PROMPT_VERSIONS = {
    "v1.0": {
        "date": "2025-10-01",
        "template": "basic_template",
        "avg_rouge": 0.45
    },
    "v1.1": {
        "date": "2025-10-05",
        "template": "improved_template",
        "avg_rouge": 0.52,
        "changes": "CoT 추가, Few-shot 예시 개선"
    },
    "v2.0": {
        "date": "2025-10-10",
        "template": "optimized_template",
        "avg_rouge": 0.58,
        "changes": "동적 프롬프트, 토큰 최적화"
    }
}
```

## 🚀 실행 계획

### Week 1: 기초 구축
- [ ] 프롬프트 템플릿 라이브러리 구축
- [ ] Zero-shot 베이스라인 설정
- [ ] 토큰 카운팅 시스템 구현

### Week 2: 최적화
- [ ] Few-shot 예시 선별
- [ ] CoT 프롬프트 실험
- [ ] A/B 테스팅 프레임워크 구축

### Week 3: 고도화
- [ ] 동적 프롬프트 선택 시스템
- [ ] 프롬프트 앙상블
- [ ] 최종 성능 튜닝

## 🎯 예상 성능 향상

| 전략 | 예상 ROUGE 향상 | 토큰 절약 |
|-----|---------------|-----------|
| Zero-shot 베이스라인 | - | - |
| Few-shot (3-shot) | +3-5% | -20% |
| CoT 프롬프팅 | +5-7% | -10% |
| 동적 프롬프트 | +2-3% | +15% |
| 프롬프트 압축 | -1% | +30% |
| **종합** | **+8-12%** | **+10%** |